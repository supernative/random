directories : <list of read-only volumes>
generators : <list of model descriptions>
executors : <list of file descriptors>
visitors : <list of node managers>

~ Go to each of the file paths.
~ Use different generators to get verbal image.
~ Use executors to interpret the embedded tasks.
~ Use high-level feedbacks for error correction requirements.

example_procedure_tree/
. directories/
  . main, send, insert, channel
. generators/
  . mono, balanced, side, monitor
. executors/
  . clip, level, mute, balance
. visitors/
  . mix, fade, pan, chain, arm, render, line, measure, compare

terminal histories:

$ ls directories/main
main.py
send.wav
insert.wav
channel.wav

$ ls directories/send
main.wav
send.py
insert.wav
channel.wav

$ ls directories/insert
main.wav
send.wav
insert.py
channel.wav

$ ls directories/channel
main.wav
send.wav
insert.wav
channel.py

$ cat directories/channel/channel.py
# level : directory <- channel <- channel.py <- *
import torchaudio
import torch
from mixer import setup_console
import os

files = []

for path in os.listdir():
    if path.endswith(".wav"):
        files.append(path)

tracks = []
rates = []

for file in files:
    data, rate = torchaudio.load(file)
    tracks.append(data)
    rates.append(rate)

frequency = sum(rates) / len(tracks)
server = setup_console(channels=len(tracks), block_size=512, samplerate=frequency)
buffer = torch.empty((2, frequency))

for i in range(len(tracks)):
    zeros = torch.zeros((len(tracks), frequency))
    zeros[i] = tracks[i]
    server.process_block(zeros, buffer)
    torchaudio.save(files[i], buffer, frequency)


Note: The same code relative to each directories aggregate their local information in/through global correlates.
